"use strict";

var net = require('net'),
    rl  = require('readline'),
    otg = require('./lib/otg_const'),
    ot  = require('./lib/ot_msg'),
    otf = require('./lib/ot_func');

// Map sensor types to Homey events
var sensorEventMap = {
	temperature: 'measure_temperature',
	pressure: 'measure_pressure',
	humidity: 'measure_humidity',
	co2: 'measure_co2',
	flow: '',
	percentage: '',
	binary: ''
};

var debugOn = false;
var testOn = false; // to trigger test cases
var client; // Net client
var waitTimer, searchTimer, reconnectTimer;
var ip_addr, ip_port; // valid when found
var locale = Homey.manager('i18n').getLanguage();
var sendQueue = [];
var responseQueue = [];
var expectingResponse = false;
var fwMajorVersion = 3;
var gatewayMode = false; // false: Monitor mode; true: Gateway mode
var found = false; // True once an OpenTherm Gateway has been found
var searching = false; // Searching for OTG is in progress
var values = {}; // Values for all OpenTherm message values
var watch = {}; // Table of variables that the user needs to be triggered on
var msg_supported = {}; // Will fill with supported messages
var searchCnt; // Nr of tries to find OTG
// Per OT variable name an array of devices: device func, device info, event ({func:, device:, event: })
var map = { CommandResponse: [{ device: null, func: null, event: 'response' }] }; 
var settings = { 
	features: { permanent: '1', ventilation: '0' }, 
	config: {} // OTG configuration
};

function otgBar2mbar(value) {
	return (value * 1000);
}

function otgResponse(value) {
	var idx = value.indexOf('=') + 1; // Remove e.g. 'PR: A='
	return (idx > 0 ? value.slice(idx) : value.slice(4));
}

// Map Homey events to get functions
var eventGetMap = {
	'measure_pressure': otgBar2mbar,
	'response': otgResponse
};

// For testing purposes only!!
var testExecuting = false;
function otgTest(cases) {
	if (testOn && !testExecuting) {
		// After 8 seconds, make sure all values needed for the tests are initialized
		setTimeout(function() {
			testExecuting = true;
			debug('>> Executing test case 1: Raise Generic Fault');
			otgProcessData('A60000000'); // reset status flags
			otgProcessData('A60050000'); // reset fault flags
		}, 8000);
		// After 10 seconds
		if (cases == null || 'fault' in cases) {
			// Test action by creating a Low Water Pressure fault after 10 secs.
			setTimeout(function() {
				testExecuting = true;
				debug('>> Executing test case 1: Raise Generic Fault');
				otgProcessData('A60000001');
			}, 10000);
		}
		if (cases == null || 'lowpressure' in cases) {
			// Test action by creating a Low Water Pressure fault after 10 secs.
			setTimeout(function() {
				testExecuting = true;
				debug('>> Executing test case 2: Low Water Pressure Fault');
				otgProcessData('A60050400');
			}, 12000);
		}
		// After 15 seconds
		if (cases == null || 'connection' in cases) {
			// Test lost connection by closing connection after 15 secs.
			setTimeout(function() {
				testExecuting = true;
				debug('>> Executing test case 3: Lost Connection');
				client.pause();
			}, 15000);
		}
	}
	testExecuting = false;
}

// Debug logging
function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// Update local config & write new configuration to the OTG
	updateConfig: function(updates) {
		var dirty = {};
		for (var id in updates) {
			var cat = updates[id].var;
			var list = updates[id].val;
			for (var item in list) {
				var value = list[item];
				if (value != null && settings[cat][item] != value) {
					debug(item + '=');
					debug(value);
					settings[cat][item] = value;
					dirty += { id: cat, var: item, val: value };
				}
			}
		}
		// Write new configuration settings
		if (found && dirty.length > 0) {
			// TODO: don't re-initiate search, just do what's needed
			otgSendInit();
		}
	},
	
	// Open communication
	openComm: function(ip, port) {
		if (found) {
			// We already found an OTG on this IP; re-connect to this every 30 seconds
			reconnectTimer = setInterval(function(){
				debug('Re-connecting to ' + ip_addr + ':' + ip_port);
				self.openComm(ip_addr, ip_port);
			}, 30000);
		}
		found = false;
		searchCnt = 0; // openComm always triggers a new search
		// Trigger all test cases
		otgTest();
		debug('Starting search on ' + ip + ':' + port);
		if (client) {
			client.destroy();
		}
		var ok = ip != null && port != null;
		if (ok) {
			client = new net.Socket();
			client.setTimeout(60000); // there should be communication at least once a second
			
			// Setup a timer that we don't wait too long while searching
			waitTimer = setTimeout(function() {
				debug('Search timed out');
				client.destroy();
				Homey.manager('api').realtime('found_otg', { found: false });
			}, 3000);
			// Register main response handler
			var line = rl.createInterface(client, client);
			line.on('line', function(data) {
				clearTimeout(waitTimer);
				otgProcessData(data);
			});
			// Error handler; likely the OTG was not found on the given ip:port
			client.on('error', function(err) {
				debug(err);
				if (!found) {
					clearTimeout(waitTimer);
					client.destroy();
					Homey.manager('api').realtime('found_otg', { found: false });
				}
			});
			client.on('timeout', function() {
				debug('Connecion timed out.');
				client.destroy();
			});
			// Handle closed connections, try to re-open it
			client.on('close', function() {
				debug('Connecion closed (found = ' + found + ')');
				if (found) {
					// Connection dropped, try to re-connect
					self.openComm(ip, port);
				}
			});
			client.connect(port, ip, function() {
				debug('Connected to ' + ip + ':' + port);
				ip_addr = ip;
				ip_port = port;
				// Kill the re-try timer
				clearTimeout(reconnectTimer);
				// Search for the OTG
				otgSearch(false);
			});
		}
		return ok;
	},
	
	// Check if we have found an OTG (true/false)
	checkFound: function() {
		return found;
	},
	
	// Set OTG configuration text & settings
	getGatewayConfig: function() {
		return settings.config;
	},
	
	// Get list of thermostats
	getThermostats: function() {
		var devices = [{ 
				name: (locale == 'nl' ? "Thermostaat" : "Thermostat"),
				data: { 
					id: "OTG:T1", 
					watch: [
						{ variable: 'CurrentTemperature', event: 'measure_temperature' },
						{ variable: 'CurrentSetpoint', event: 'target_temperature' },
						{ variable: 'RemoteOverrideRoomSetpoint', event: 'target_temperature', condition: '>0' },
						{ variable: 'StatusFlame', event: 'flame_on' }
					]
				}
			}];
		if (msg_supported[23]) {
			devices[1] = { 
				name: (locale == 'nl' ? "Verwarming 2" : "Heating 2"),
				data: { 
					id: "OTG:T2", 
					watch: [
						{ variable: 'CH2CurrentSetpoint', event: 'target_temperature' }
					]
				},
				capabilities: [ 'target_temperature' ]
			};
		}
		return devices;
	},
	
	// Get list of sensors of type <sort>
	getSensors: function(sort) {
		var devices = [];
		var cnt = 0;
		for (var nr in ot.Messages) {
			var msg = ot.Messages[nr];
			// If sort is not defined, show all types, but only if the message already has a value.
			// We want to prevent to show sensors that are not supported by either boiler or thermostat.
			if ((sort == null || msg.sensor == sort) && values[msg.var]) {
				devices[cnt++] = {
					name: msg[locale] || msg.en,
					data: {
						id: 'OTG:' + nr,
						watch: [{ variable: msg.var, event: sensorEventMap[msg.sensor] }]
					}
				};
			}
		}
		return devices;
	},
	
	// Add an OTG device
	addDevice: function(func, device) {
		debug("Adding device " + device.id);
		if (device.watch) {
			device.watch.forEach(function(element) {
				if (map[element.variable] == null) {
					map[element.variable] = [];
				}
				debug("Watching variable " + element.variable);
				if (element.get) {
					// We need to evaluate the function call at this point.
					element.get = eval(element.get);
				};
				// Add information of the device to our real-time update map
				map[element.variable].push({ func: func, device: device, event: element.event, condition: element.condition });
				// Immediately send a (forced) update of the variable if available
				otgUpdateIfNeeded(element.variable, values[element.variable], true);
			});
		}
	},
	
	// Remove an OTG device
	deleteDevice: function(device) {
		debug("Deleting device " + device.id);
		for (var id in device.watch) {
			// Remove this device from the map
			var name = device.watch[id].variable;
			debug("Un-watching " + name);
			delete map[name];
		}
	},
	
	// Return list of variables than can be watched
	getLoggableVars: function() {
		var list = [];
		// Using values table to include override values
		for (var v in values) {
			var item = self.getVarDetails(v);
			if (item != null) {
				var text = item.data[locale] || item.data.en;
				list.push({ id: item.idx, var: v, txt: text });
			}
		}
		return list;
	},
	
	// Get variables from a flag table
	getFlagVars: function(name) {
		var set = {};
		if (name.slice(-5) == 'Flags' && ot[name] != null) {
			for (var item in ot[name]) {
				set[ot[name][item].var] = { txt: { en: ot[name][item].en, nl: ot[name][item].nl }};
			}
		}
		return set;
	},
	
	// Get all information related to a variable (i.e. OpenTherm details)
	getVarDetails: function(name) {
		// Variable names are unique over all tables, so return the first one we find
		for (var tab in ot) {
			for (var item in ot[tab]) {
				var entry = ot[tab][item];
				if (entry.var != null && (entry.var == name || entry.var.lb == name || entry.var.hb == name)) {
					var idx = tab == 'Messages' ? ('000' + item).slice(-3) : '#' + tab + '.' + item; // flags on top
					return { idx: idx, data: entry };
				}
			}
		}
	},
	
	// Send a trigger when a value changes
	registerWatch: function(variable, id, callback) {
		if (watch[variable] == null) {
			watch[variable] = [];
		}
		watch[variable].push({ id: id, callback: callback });
	},
	
	// Stop watching a variable
	removeWatch: function(variable, id) {
		if (id == null) {
			delete watch[variable];
		} else {
			for (var w in watch[variable]) {
				if (watch[variable][w].id == id) {
					delete watch[variable][w];
				}
			}
		}
	},
	
	// Get an OTG variable value for a certain event (null = get raw value)
	getValue: function(event, variable) {
		var value = values[variable];
		if (value != null && event != null) {
			var get = eventGetMap[event];
			if (typeof get == 'function') {
				value = get(value);
			}
		}
		return value;
	},
	
	// Set the target temperature
	setTargetTemp: function(device, value) {
		if (device.id == 'OTG:T1' && gatewayMode) {
			var cmd = 'TT='; // temporary temperature
			if (settings.features.permanent == '1') {
				cmd = 'TC='; // constant temperature
			}
			otgWriteCommand(cmd + value);
		} else if (device.id == 'OTG:T2' && gatewayMode) {
			// TODO: figure out to use SR command
			debug('Second thermostat not supported yet');
		}
	},
	
	// Get the current mode of the thermostat
	getThermostatMode: function(device) {
		var state = (values.RemoteOverrideRoomSetpoint > 0 ? 'heat' : 'auto'); // TODO: test
		return state;
	},
	
	// Set the mode of the thermostat: auto = resume program
	setThermostatMode: function(device, mode) {
		if (mode == 'auto' && gatewayMode) {
			otgWriteCommand('TT=0');
		}
	},
	
	// Get the state of the boiler (e.g. flame state)
	getThermostatState: function(device, state) {
		var err;
		switch (state) {
			case 'flame_on': state = self.getValue(state, 'StatusFlame'); break;
			case 'heating_on': state = self.getValue(state, 'StatusCHMode'); break;
			case 'cooling_on': state = self.getValue(state, 'StatusCooling'); break;
			case 'heating_water': state = self.getValue(state, 'StatusDHWMode'); break;
			case 'fault':  state = self.getValue(state, 'StatusFault'); break;
			default: err = 'unknown state ' + state;
		}
		return { err: err, state: state };
	},
	
	// Send time and date to the thermostat
	setClock: function(date) {
		debug("setClock");
		if (date == null) {
			date = new Date();
		}
		if (gatewayMode) {
			var now = { 
				day: date.getDate(), wday: date.getDay(), month: date.getMonth(), year: date.getFullYear(),
				hour: date.getHours(), min: date.getMinutes(), sec: date.getSeconds() 
			};
			var dow = now.wday == 0 ? 7 : now.wday;
			otgWriteCommand('SC=' + now.hour + ':' + ('0' + now.min).slice(-2) + '/' + dow);
			if (fwMajorVersion >= 4) { // SR command only available from FW4
				otgWriteCommand('SR=21:' + now.month + ',' + now.day)
				var hb = Math.floor(now.year / 0x100);
				var lb = now.year % 0x100;
				otgWriteCommand('SR=22:' + hb + ',' + lb);
			}
		} else {
			return false;
		}
		return true;
	},
	
	// Control the domestic hot water enable option
	setHotWater: function(newMode) {
		debug("setHotWater " + (newMode || ''));
		var dmw_t = { thermostat: 'A', off: '0', on: '1' };
		if (dmw_t[newMode] != null) {
			otgWriteCommand('HW=' + dmw_t[newMode]);
			return true;
		} else {
			return false
		}
	},
	
	// Use e.g. another sensor to set the outside temperature
	setOutsideTemperature: function(newTemperature) {
		debug("setOutsideTemperature " + (newTemperature | ''));
		if (gatewayMode) {
			otgWriteCommand('OT=' + newTemperature); // Outside temperature
		} else {
			return false;
		}
		return true;
	},
	
	// Use e.g. another sensor to update the measured humidity
	setRoomHumidity: function(newLevel) {
		debug("setRoomHumidity " + (newLevel | ''))
		if (gatewayMode) {
			otgWriteCommand('SR=78:' + newLevel + ',0'); // Outside temperature
		} else {
			return false;
		}
		return true;
	},
	
	// Send a free-format command
	sendCommand: function(command) {
		if (command != null) {
			var cmd = command.substr(0, 2);
			if (command[2] == '=' && otg.Commands.indexOf(cmd) >= 0) {
				// Valid OTG command
				otgWriteCommand(command, true);
				return true;
			}
		}
		return false;
	}
}

// Write a message or enqueue
function otgWriteCommand(cmd, response) {
	if (cmd == null) {
		if (sendQueue.length > 0) {
			var val = sendQueue.shift();
			return otgWriteCommand(val.cmd, val.ret)
		} else {
			return false
		}
	} else if (responseQueue.length == 0) {
		client.write(cmd + '\r');
		debug("Sent command " + cmd)
		if (response != null && response == true) {
			otgUpdateIfNeeded("CommandResponse", "");
			expectingResponse = true;
		} else if (response == null) {
			if (fwMajorVersion >= 4) {
				response = cmd.replace(/=/, ": ");
				response = response.replace(/,/g, "/");
			} else {
				response = "OK";
			}
			responseQueue.push(response);
		} else if (typeof response == 'string') {
			responseQueue.push(response);
		}
	} else {
		sendQueue.push({cmd: cmd, ret: response});
	}
}

// Update variable value if needed and send message to Homey
function otgUpdateIfNeeded(name, newValue, forced) {
	var oldValue = values[name];
	var newRawValue = newValue;
	if (name != null && newValue != null && (oldValue != newValue || forced)) {
		values[name] = newValue;
		debug('Updating value of ' + name + ' to ' + newValue);
		if (map[name]) {
			map[name].forEach(function(element) {
				var get = eventGetMap[element.event];
				if (typeof get == 'function') {
					newValue = get(newValue);
				}
				if (element.device != null) {
					var update = true;
					if (element.condition != null) {
						// Evaluate condition
						debug('Evaluating condition ' + name + element.condition);
						update = eval(newValue + element.condition);
					}
					if (update) {
						debug("Sending real-time event " + element.event + " for device " + element.device.id + ' (' + name + '=' + newValue + ')');
						element.func.realtime(element.device, element.event, newValue, function(err, success) {
							if (err) { debug('! Realtime: ' + err); }
						});
					}
				}
			});
		}
		// Call user functions that are registered
		if (watch[name] != null) {
			for (var w in watch[name]) {
				debug('Calling function for ' + watch[name][w].id);
				var callback = watch[name][w].callback;
				callback(watch[name][w].id, { name: name, oldValue: oldValue, newRawValue: newRawValue, newTxtValue: newValue });
			}
		}
	}
}

// Add a configuration setting we just found
function otgAddConfig(idx, val) {
	var name = otg.Config[idx].var;
	var tab = otg.Config[idx].tab;
	var cnt = otg.Config[idx].cnt;
	var loop = cnt || 1;
	debug('Setting read: ' + name + ' = ' + val);
	for (var i = 0; i < loop; i++) {
		var txtVal = val;
		var txtName = otg.Config[idx][locale] || otg.Config[idx].en; // default to English if needed
		var itemVal = val;
		var itemName = name;
		if (cnt != null) {
			itemName = name + i;
			itemVal = val[i];
			txtName = txtName.replace(/<(.)>/, function(x) { return String.fromCharCode(x[1].charCodeAt(0) + i) });
		}
		if (tab != null) {
			txtVal = otg[tab][itemVal][locale] || otg[tab][itemVal].en; // default to English if needed
		}
		settings.config[itemName] = { txt: txtName, val: itemVal, txtVal: txtVal, mod: otg.Config[idx].cmd != null };
	}
	Homey.manager('api').realtime('config_change', settings.config);
}

// Search for OTG
function otgSearch() {
	if (searchCnt++ < 3) {
		otgWriteCommand('PR=' + otg.Config.VER.rep, "VER");
		searchTimer = setTimeout(otgSearch, 1000);
		debug("Search attempt " + searchCnt);
	} else {
		Homey.manager('api').realtime('found_otg', { found: false });
	}
}

// Send initialization commands
function otgSendInit() {
	// Fake ventilation if needed
	if (settings.features.ventilation == '1') {
		otgWriteCommand('SR=70:0,0');
	} else {
		otgWriteCommand('CR=70');
	}
	// Read Gateway settings to store them locally
	for (var i = 0; i < otg.Startup.length; i++) {
		var item = otg.Startup[i];
		if (otg.Config[item] && otg.Config[item].rep) {
			var cmd = 'PR=' + otg.Config[item].rep;
			otgWriteCommand(cmd, item);
		}
	}
}

// Local data processing function
function otgProcessData(data) {
	var str = String(data);
	var res = str.match(/^(A|B|R|T)[0-9A-F]{8}$/);
	if (res != null) { 
		// Found OpenTherm communication data
		var sender = otg.Initiator[str[0]];
		var ctype = otg.MsgType[parseInt(str[1], 16) & 0x7];
		var msg = parseInt(str.substr(3, 2), 16);
		if (ot.Messages[msg] != null) {
			var msgName = ot.Messages[msg].en;
			var val1 = parseInt(str.substr(5, 2), 16);
			var val2 = parseInt(str.substr(7, 2), 16);
			var val = 0

			// Keep track of unsupported message IDs
			var override = (sender == "Answer" || sender == "Response");
			if ((ctype == "Read-Ack" || ctype == "Write-Ack") && msg_supported[msg] == null && override == false) {
				msg_supported[msg] = true;
			}
 
			// Determine if the value received will update the variable
			var valid = false;
			if (ctype == "Read-Ack") {
				valid = (override == true && msg_supported[msg] == null) || (override == false && msg_supported[msg] != null);
			} else if (ctype == "Write-Data") {
				valid = true;
			} else if (ctype == "Data-Invalid") {
				valid = override;
			}

			if (valid == true) {
				// If needed: format flags
				var msgFlags = ot.Messages[msg].flags;
				if (msgFlags != null) {
					msgFlags = ot[msgFlags];
					val = val1 * 256 + val2;
					for (var flag in msgFlags) {
						var item = msgFlags[flag];
						var flagVal = (val & parseInt(flag, 16)) ? true : false;
						//debug(">> " + item.txt + ": " + flagVal);
						if (item.var != null) {
							otgUpdateIfNeeded(item.var, flagVal)
						}
					}
				}
				// Format value
				var msgVal = ot.Messages[msg].val;
				if (typeof msgVal === 'object') {
					val = otf.decode(val1, msgVal.hb) + ' ' + otf.decode(val2, msgVal.lb)
				} else {
					val = otf.decode(val1, msgVal, val2)
				}
				var variable = ot.Messages[msg].var;
				if (variable != null) {
					if (typeof variable == 'object') {
						otgUpdateIfNeeded(variable.hb, val1);
						otgUpdateIfNeeded(variable.lb, val2);
					} else {
						otgUpdateIfNeeded(variable, val);
					}
				}
			}
			//debug(res[0] + ' ' + sender + ', ' + ctype + ', ' + msgName + ': ' + val);
		 } else {
			debug('Unknown OpenTherm message ID ' + msg);
		}
	} else if (expectingResponse == true) { // Receive queue handling
		expectingResponse = false
		otgUpdateIfNeeded("CommandResponse", str);
	} else if (responseQueue.length > 0) {
		var elem = responseQueue.shift();
		var elem_t = otg.Config[elem];
		if (elem_t != null) { // a known message
			var val = str.match(new RegExp(elem_t.ret)); // check expected response
			if (val != null) {
				val = val[1]; // matched item is in second entry
			}
			if (val != null && elem_t.map != null) { // apply mapping if available
				for (var key in elem_t.map) {
					if (val.match(key) != null) {
						val = elem_t.map[key];
					}
				}
			}
			if (val != null) { // valid response
				otgAddConfig(elem, val);
				// call specific message handler (if available)
				if (elem_t.handler != null) {
				   elem_t.handler(data, val);
				}
			} else {
				debug("Error for cmd: " + elem + "; expected " + elem_t.ret + " but got " + str);
			}
		} else if (str.match(elem) == null && str.match(/: NF/) == null) { // Ignore NF (Not Found) errors
			 debug("Error: expected " + elem + " but got " + str);
			 // Put expected message back on top of queue
			 responseQueue.unshift(elem);
		}
	} else {
		// Other OTG traffic
		debug(str);
	}
	otgWriteCommand(); // Write next command if there is one in the queue
}

// Message handlers
otg.Config.VER.handler = function(cmd, version) {
	// Found PR=A (version information)
	fwMajorVersion = version.match(/\d/);
	found = true;
	clearTimeout(searchTimer);
	Homey.manager('api').realtime('found_otg', { found: true, ip: ip_addr, port: ip_port });
	debug("Found OpenTherm Gateway firmware version " + version + ' (major=' + fwMajorVersion + ')');
	// Update configuration based on version
	if (otg.VersionConfig[fwMajorVersion]) {
		for (var key in otg.VersionConfig[fwMajorVersion]) {
			if (otg.Config[key] == null) {
				otg.Config[key] = {}; // new command
			}
			for (var x in otg.VersionConfig[fwMajorVersion][key]) {
				otg.Config[key][x] = otg.VersionConfig[fwMajorVersion][key][x];
			}
		}
	}
	otgSendInit();
}

otg.Config.GW.handler = function(cmd, mode) {
	gatewayMode = (mode == '1');
	debug('Gateway mode is now ' + gatewayMode);
}